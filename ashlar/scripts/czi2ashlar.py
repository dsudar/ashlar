#!/usr/bin/python3

# czi2ashlar.py: converts/tiles/registers a list of CZI files generated by the OHSU workflow into a single tiled/pyramid OME-TIFF
# this wrapper around Ashlar is mostly for metadata handling for the OHSU workflow
# copyright  Damir Sudar Quantitative Imaging Systems LLC and OHSU

import argparse
import sys
import glob
import os
import tempfile
import subprocess
import re
from pylibCZIrw import czi as pyczi
from ashlar.scripts.ashlar import main as ashlar_main

def main():
    # CZI Stitching/Registration and converter to OME-TIFF
    # based on ashlar https://github.com/jmuhlich/ashlar
    # this module extract metadata from the CZI files, saves to a csv file, and calls ashlar
    # 

    # The arguments:
    # 1. Get the list of individual CZI files
    # 3. Options:
    #       -o out.ome.tif: output path of where to save the resulting OME-TIFF file and CSV metadata table.
    #       -q stops verbose output

    # command line processing of arguments
    parser = argparse.ArgumentParser(
            description='czi2ashlar.py: convert a list of CZI files generated by the OHSU workflow into a single pyramidal OME-TIFF file',
            )
    parser.add_argument(
            "filepaths", metavar='FILE', nargs='+',
            help="Provide list of CZI files to be processed",
            )
    parser.add_argument(
            "-o", "--output", dest="output", default="ashlar_output.ome.tif", metavar='PATH',
            help="Provide a path/name for the output OME-TIFF file",
            )
    parser.add_argument(
            "-q", "--quiet", dest="quiet",
            help="Suppress verbose status and progress display", action="store_true", default=False,
            )
 
    args = parser.parse_args()
 
    filepaths = args.filepaths
 
    verbose = not args.quiet
 
    # create a name/path for the csv output file
    out_path_csv = '{}.csv'.format(args.output)
 
    # the regex pattern of the single channel registered tif files
    cycif_pattern=re.compile("^R([0-9]+)_([a-zA-Z0-9-]+)\.?([a-zA-Z0-9-]+)?\.?([a-zA-Z0-9-]+)?\.?([a-zA-Z0-9-]+)?_?([a-zA-Z]?)([0-9]+)?_([a-zA-Z0-9-_()]+).czi")
 
    # csv file collects metadata extracted from filenames
    of = open(out_path_csv, "w")
    of.write("Channel,Name,Cycle,ChannelIndex,ExposureTime,ExposureTimeUnit,Fluor,AcquisitionMode,IlluminationType,ContrastMethod,ExcitationWavelength,ExcitationWavelengthUnit,EmissionWavelength,EmissionWavelengthUnit,Color\n")
 
    if verbose: print("Metadata extracted from files found:")
    if verbose: print("Cycle\tBM1\tBM2\tBM3\tBM4\tName\t\tScene")
 
    # channel counter increments while stepping through the individual czi files
    chan_count = 0
 
    # TODO add handling of TMAs and image/scene positions
    # scene_x = scene_y = 0.0
    # tma_flag = True

    for fname in filepaths:
        inbasename = os.path.basename(fname)
        if cycif_pattern.match(inbasename):
            # if regex match found, extract all the embedded metadata from filename
            match = cycif_pattern.search(inbasename)
            cycle = int(match.group(1))
            bm1 = match.group(2)
            bm2 = match.group(3)
            bm3 = match.group(4)
            bm4 = match.group(5)
            let_coor = match.group(6)
            if match.group(7): scene = int(match.group(7))
            else: scene = 0
            basename = match.group(8)
 
            exp_time = 0.0
 
            if verbose: print("%d\t%s\t%s\t%s\t%s\t%s\t%s%d" % (cycle, bm1, bm2, bm3, bm4, basename, let_coor, scene), end = ' ')
 
            if verbose: print("    Accepting: ", inbasename)
 
            with pyczi.open_czi(fname) as czidoc:
                md_dict = czidoc.metadata
 
            chanindex = 0
            # add entry for a numbered DAPI channel
            exp_time = float(md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][0]['ExposureTime']) / 1000000.0
            fluor = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][0]['Fluor']
            acq_mode = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][0]['AcquisitionMode']
            illum_type = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][0]['IlluminationType']
            con_meth = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][0]['ContrastMethod']
            color = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][0]['Color']
            ex_wave = float(md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][0]['ExcitationWavelength'])
            em_wave = float(md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][0]['EmissionWavelength'])

            chan_line = "%d,DAPI%d,%d,%d,%f,ms,%s,%s,%s,%s,%f,nm,%f,nm,%s\n" % (chan_count, cycle, cycle, chanindex, exp_time, fluor, acq_mode, illum_type, con_meth, ex_wave, em_wave, color )
            chanindex += 1
            chan_count += 1
            of.write(chan_line)
            if bm1:
                exp_time = float(md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][1]['ExposureTime']) / 1000000.0
                fluor = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][1]['Fluor']
                acq_mode = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][1]['AcquisitionMode']
                illum_type = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][1]['IlluminationType']
                con_meth = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][1]['ContrastMethod']
                color = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][1]['Color']
                ex_wave = float(md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][1]['ExcitationWavelength'])
                em_wave = float(md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][1]['EmissionWavelength'])
                chan_line = "%d,%s,%d,%d,%f,ms,%s,%s,%s,%s,%f,nm,%f,nm,%s\n" % (chan_count, bm1, cycle, chanindex, exp_time, fluor, acq_mode, illum_type, con_meth, ex_wave, em_wave, color )
                chanindex += 1
                chan_count += 1
                of.write(chan_line)
            if bm2:
                exp_time = float(md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][2]['ExposureTime']) / 1000000.0
                fluor = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][2]['Fluor']
                acq_mode = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][2]['AcquisitionMode']
                illum_type = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][2]['IlluminationType']
                con_meth = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][2]['ContrastMethod']
                color = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][2]['Color']
                ex_wave = float(md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][2]['ExcitationWavelength'])
                em_wave = float(md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][2]['EmissionWavelength'])
                chan_line = "%d,%s,%d,%d,%f,ms,%s,%s,%s,%s,%f,nm,%f,nm,%s\n" % (chan_count, bm2, cycle, chanindex, exp_time, fluor, acq_mode, illum_type, con_meth, ex_wave, em_wave, color )
                chanindex += 1
                chan_count += 1
                of.write(chan_line)
            if bm3:
                exp_time = float(md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][3]['ExposureTime']) / 1000000.0
                fluor = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][3]['Fluor']
                acq_mode = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][3]['AcquisitionMode']
                illum_type = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][3]['IlluminationType']
                con_meth = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][3]['ContrastMethod']
                color = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][3]['Color']
                ex_wave = float(md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][3]['ExcitationWavelength'])
                em_wave = float(md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][3]['EmissionWavelength'])
                chan_line = "%d,%s,%d,%d,%f,ms,%s,%s,%s,%s,%f,nm,%f,nm,%s\n" % (chan_count, bm3, cycle, chanindex, exp_time, fluor, acq_mode, illum_type, con_meth, ex_wave, em_wave, color )
                chanindex += 1
                chan_count += 1
                of.write(chan_line)
            if bm4:
                exp_time = float(md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][4]['ExposureTime']) / 1000000.0
                fluor = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][4]['Fluor']
                acq_mode = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][4]['AcquisitionMode']
                illum_type = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][4]['IlluminationType']
                con_meth = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][4]['ContrastMethod']
                color = md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][4]['Color']
                ex_wave = float(md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][4]['ExcitationWavelength'])
                em_wave = float(md_dict['ImageDocument']['Metadata']['Information']['Image']['Dimensions']['Channels']['Channel'][4]['EmissionWavelength'])
                chan_line = "%d,%s,%d,%d,%f,ms,%s,%s,%s,%s,%f,nm,%f,nm,%s\n" % (chan_count, bm4, cycle, chanindex, exp_time, fluor, acq_mode, illum_type, con_meth, ex_wave, em_wave, color )
                chanindex += 1
                chan_count += 1
                of.write(chan_line)
        else:
             if verbose: print("File \"%s\" does not match regular cycle definition - skipped. " % inbasename)
 
    of.close()

    if chan_count == 0:
        if verbose: print("No valid channel files found in \"%s\" - cannot proceed." % filepaths)
        sys.exit()
 
    if verbose: print("Done with metadata extraction")
 
    # construct the argument list
    arglist = ["-q", "--flip-y", "-o", args.output, "--metadata", out_path_csv]
    if args.quiet: arglist += ["-q"]
 
    arglist += filepaths

    # print(arglist)
    ashlar_main(arglist)
 
if __name__ == '__main__':
    main()

